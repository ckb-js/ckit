import { Amount, Cell, CellDep, DepType, HashType, OutPoint, RawTransaction, Script, Transaction } from '@lay2/pw-core';

// generated by https://github.com/jvilk/MakeTypes
export interface SerializedTx {
  raw: Raw;
  witnessArgs: (WitnessArgsEntity | string)[];
  witnesses: string[];
}
export interface Raw {
  inputCells: InputCellsEntity[];
  outputs: OutputsEntity[];
  cellDeps: CellDepsEntity[];
  headerDeps: string[];
  version: string;
  inputs: InputsEntity[];
  outputsData?: string[];
}
export interface InputCellsEntity {
  capacity: Capacity;
  lock: LockOrType;
  type?: LockOrType;
  outPoint?: OutPointOrPreviousOutput;
  data: string;
}
export interface Capacity {
  amount: string;
}
export interface LockOrType {
  codeHash: string;
  args: string;
  hashType: string;
}
export interface OutPointOrPreviousOutput {
  txHash: string;
  index: string;
}
export interface OutputsEntity {
  capacity: Capacity;
  lock: LockOrType;
  data: string;
  type?: LockOrType;
}
export interface OutPointOrPreviousOutput1 {
  txHash: string;
  index: string;
}

export interface CellDepsEntity {
  depType: string;
  outPoint: OutPointOrPreviousOutput;
}
export interface InputsEntity {
  previousOutput: OutPointOrPreviousOutput;
  since: string;
}
export interface WitnessArgsEntity {
  lock: string;
  input_type: string;
  output_type: string;
}

export function serialize(tx: Transaction): SerializedTx {
  const raw = tx.raw;
  return {
    raw: {
      inputs: raw.inputs.map<InputsEntity>((item) => ({
        since: item.since,
        previousOutput: { index: item.previousOutput.index, txHash: item.previousOutput.txHash },
      })),
      inputCells: raw.inputCells.map<InputCellsEntity>((item) => ({
        lock: { args: item.lock.args, codeHash: item.lock.codeHash, hashType: item.lock.hashType },
        type: item.type && { args: item.type.args, hashType: item.type.hashType, codeHash: item.type.codeHash },
        data: item.getHexData(),
        capacity: { amount: item.capacity.toHexString() },
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        outPoint: { txHash: item.outPoint!.txHash, index: item.outPoint!.index },
      })),
      outputs: raw.outputs.map<OutputsEntity>((item) => ({
        capacity: { amount: item.capacity.toHexString() },
        data: item.getHexData(),
        lock: {
          args: item.lock.args,
          hashType: item.lock.hashType,
          codeHash: item.lock.codeHash,
        },
        type: item.type && { args: item.type.args, hashType: item.type.hashType, codeHash: item.type.codeHash },
      })),
      version: raw.version,
      cellDeps: raw.cellDeps.map<CellDepsEntity>((item) => ({
        depType: item.depType,
        outPoint: { index: item.outPoint.index, txHash: item.outPoint.txHash },
      })),
      headerDeps: raw.headerDeps,
    },
    witnessArgs: tx.witnessArgs,
    witnesses: tx.witnesses,
  };
}

function toScript(x: LockOrType): Script {
  return new Script(x.codeHash, x.args, x.hashType === 'type' ? HashType.type : HashType.data);
}

function toCell(x: InputCellsEntity | OutputsEntity): Cell {
  return new Cell(
    new Amount(x.capacity.amount, 0),
    toScript(x.lock),
    x.type ? toScript(x.type) : undefined,
    'outPoint' in x && x.outPoint ? new OutPoint(x.outPoint.txHash, x.outPoint.index) : undefined,
    x.data,
  );
}

export function deserialize(tx: SerializedTx): Transaction {
  const raw = tx.raw;
  return new Transaction(
    new RawTransaction(
      raw.inputCells.map(toCell),
      raw.outputs.map(toCell),
      raw.cellDeps.map(
        (item) =>
          new CellDep(
            item.depType === 'code' ? DepType.code : DepType.depGroup,
            new OutPoint(item.outPoint.txHash, item.outPoint.index),
          ),
      ),
      raw.headerDeps,
      raw.version,
    ),
    tx.witnessArgs,
  );
}
